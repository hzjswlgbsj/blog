
# Websocket 信令设计

## 1 信令传输基本概念

WebSocket 是一种在客户端与服务器之间建立 **全双工通信** 的协议，适用于高频、低延迟的实时数据传输场景，如 **在线协同编辑、WebRTC 会议、多人游戏等**。在这些场景中，我们需要设计一套高效、稳定的 **信令传输协议**，确保数据能够 **快速传输、正确解析，并能高效扩展**。

信令一般指用于 **控制和同步状态的消息**，例如：

- **WebRTC 会议**：开启/关闭摄像头、切换音频设备、管理成员等。

- **在线协同编辑**：文本变更、光标位置同步、撤销/重做等。

- **多人游戏**：角色移动、技能释放、游戏状态同步等。

假设我们有一个 WEB RTC 会议应用，有一个场景就是在会议中可以控制麦克风的开关、摄像头的开关等，这时候我们就需要设计一个 WebSocket 信令传输协议，来实现这些功能。

接下来我们基于这个场景来做信令设计，并分析一下几种常见的设计方案，以及它们的优缺点。

## 2 信令设计的几种常见方案

### 2.1 信令设计的衡量标准

既然是几种常见的设计方案的比较，那就需要定义一个衡量标准，来评估不同的方案是否适合我们的需求。

在设计 WebSocket 信令时，通常需要考虑以下几个关键因素：

| 评估标准     | 说明                              |
| -------- | ------------------------------- |
| **数据体积** | 传输的数据应尽可能小，减少带宽占用，提高传输效率。       |
| **可读性**  | 数据结构应尽量清晰，方便开发人员理解和调试。          |
| **可维护性** | 未来扩展和修改信令结构时，应尽量减少对已有逻辑的影响。     |
| **解析效率** | 服务器和客户端解析数据的速度应该尽可能快，减少 CPU 负担。 |
| **通用性**  | 设计的协议应能适应不同的业务场景，具备良好的扩展性。      |

### 2.2 信令设计的常见方案

#### **方案 1：使用 JSON 结构化数据**

**示例：WebRTC 会议中用户开启麦克风**

```json
{
 "type": "control",
 "action": "enable_media",
 "target": "user1",
 "device": "microphone",
 "value": 1
}
```

**适用场景：**

- WebRTC 会议系统
- 在线文档协作
- 需要较强可读性的业务

**优缺点分析：**

- ✅ **可读性强**，易于调试。
- ✅ **通用性好**，大部分语言都支持 JSON 解析。
- ❌ **数据体积较大**，字段名增加了额外的数据开销。
- ❌ **解析速度一般**，JSON 解析相对二进制慢。

#### **方案 2：使用数组编码**

**示例：WebRTC 会议中用户开启麦克风**

```json
[3, 1, "user1", 1]
```

**解析：**

- `3` 表示 "开启媒体"（业务行为）。
- `1` 代表 "麦克风"（设备类型）。
- `"user1"` 是被操作的用户。
- `1` 代表 "开启"。

**适用场景：**

- 高频信令，如游戏、IoT 设备
- 网络带宽受限的情况

**优缺点分析：**

- ✅ **数据体积小**，减少带宽消耗。
- ✅ **传输性能好**，适合高频信令。
- ❌ **可读性差**，字段无明确意义，需查阅文档。
- ❌ **可维护性低**，字段顺序不能随意更改。

#### **方案 3：使用 Protobuf（二进制编码）**

**示例：定义 Protobuf 消息结构**

```proto
message Signal {
 required int32 action = 1; // 3: 开启媒体
 required int32 device = 2; // 1: 麦克风
 required string target = 3; // user1
 required bool value = 4; // 1: 开启, 0: 关闭
}
```

**适用场景：**

- WebRTC、大型协作系统
- 需要兼顾 **高效解析** 和 **扩展性** 的系统

**优缺点分析：**

- ✅ **数据体积小**，相比 JSON **节省 30-70%** 的数据。
- ✅ **解析速度快**，适合大规模高并发场景。
- ❌ **调试不便**，二进制数据不易直接查看。
- ❌ **前端需要额外库**，如 `protobuf.js`。

## 3. WebSocket 信令日志方案

由于 WebSocket 信令传输 **高频、实时性强**，故日志方案至关重要。

### 3.1 日志记录方案

**设计 Logger 类：**

```typescript
class WebSocketLogger {
 private logs: any[] = [];
 private maxLogSize = 100;
 
 log(message: any) {
  const logEntry = {
   timestamp: new Date().toISOString(),
   message,
  };
  
  console.log("WebSocket Log:", logEntry);
  this.logs.push(logEntry);
  if (this.logs.length > this.maxLogSize) {
   this.uploadLogs();
   this.logs = [];
  }
 }

 private uploadLogs() {
  // 上传日志到 OSS
  fetch("/api/logs/upload", {
   method: "POST",
   body: JSON.stringify(this.logs),
  });
 }
}
```

**日志存储策略：**

- **浏览器本地缓存（LocalStorage / IndexedDB）**，防止数据丢失。
- **服务器端存储（上传至 OSS / 日志服务）**，支持长期分析。

## 4. 如何决策，如何优化？

1. **优先考虑 JSON（适合大多数业务场景）**
2. **极限优化时，使用数组编码（如游戏、IoT）**
3. **如果性能瓶颈明显，使用 Protobuf**
4. **压缩优化：启用 WebSocket Gzip 压缩**
5. **减少信令次数：批量合并发送，减少 WebSocket 负担**
6. **完善日志方案，确保可追踪、可调试**

## 5. 总结

- WebSocket 信令的设计需要平衡 **体积、解析效率、可读性、扩展性**。
- JSON 适用于大部分业务，**简单直观但数据较大**。
- 数组编码适用于**极端优化场景**（如游戏、IoT）。
- Protobuf 在高并发场景下**优势明显**，推荐 WebRTC、IM 业务使用。
- **配合 Gzip 压缩和批量合并策略**，进一步减少 WebSocket 负担，提高性能。
- **完善日志方案，提高系统可观测性，便于问题排查**。

**最终方案选择需结合业务需求和技术环境综合考虑！** 🚀

# 树的操作与运用

树结构在前端开发中非常常见，无论是权限菜单、分类管理，还是组织架构图，几乎都离不开树形数据。本文将从基础操作讲起，逐步带你了解树的构建、操作、搜索、序列化、结构设计等内容，帮助你建立完整的树结构知识体系。

---

## 一、树的基础操作

### 新增节点

树中添加节点时，通常是将一个新节点添加到指定父节点的 `children` 数组中。例如：

```ts
function addChild(tree, parentId, newNode) {
  for (const node of tree) {
    if (node.id === parentId) {
      node.children = node.children || [];
      node.children.push(newNode);
      return true;
    }
    if (node.children && addChild(node.children, parentId, newNode)) {
      return true;
    }
  }
  return false;
}
```

如果树要求有序，比如按名称排序，我们可能需要根据某个规则将新节点插入到指定位置。

### 删除节点

删除节点时，通常有两种策略：

1. **连同子节点一起删除**：适用于权限菜单、组织架构等需要完整移除的情况。
2. **子节点提升一级或交给上级管理**：例如某些电商分类，当中间层级删除时，可以选择保留其子分类。

示例：递归删除某个 `id` 的节点及其所有子节点。

```ts
function deleteNode(tree, nodeId) {
  return tree.filter((node) => {
    if (node.id === nodeId) return false;
    if (node.children) {
      node.children = deleteNode(node.children, nodeId);
    }
    return true;
  });
}
```

### 更新节点

更新操作很常见，比如修改节点名称、状态、扩展字段等：

```ts
function updateNode(tree, nodeId, patch) {
  for (const node of tree) {
    if (node.id === nodeId) {
      Object.assign(node, patch);
      return true;
    }
    if (node.children && updateNode(node.children, nodeId, patch)) {
      return true;
    }
  }
  return false;
}
```

### 移动节点

支持拖拽操作的树组件，背后就是节点的“剪切-粘贴”操作。需要特别注意的是跨层级拖动可能引起**循环引用**，即一个节点被移到自己的子孙节点中，形成死循环。

为了防止这种情况，我们需要在移动前做合法性校验。

```ts
function isDescendant(sourceNode, targetId) {
  if (!sourceNode.children) return false;
  for (const child of sourceNode.children) {
    if (child.id === targetId || isDescendant(child, targetId)) {
      return true;
    }
  }
  return false;
}
```

---

## 二、树的搜索功能

### 根据关键词搜索节点

我们常常需要根据节点名称进行模糊搜索，比如在一个 1000 个分类的商品分类树中快速定位“面部护理”。

```ts
function searchTree(tree, keyword) {
  const result = [];
  for (const node of tree) {
    const hasMatch = node.name.includes(keyword);
    const matchedChildren = node.children
      ? searchTree(node.children, keyword)
      : [];
    if (hasMatch || matchedChildren.length) {
      result.push({
        ...node,
        children: matchedChildren,
      });
    }
  }
  return result;
}
```

### 返回路径链（路径高亮）

当匹配到某个节点时，我们希望展示完整路径，如：

```
[根节点 → 分类A → 子分类B → 目标节点]
```

我们可以在搜索过程中将路径保存下来：

```ts
function findPath(tree, targetId, path = []) {
  for (const node of tree) {
    const newPath = [...path, node];
    if (node.id === targetId) return newPath;
    if (node.children) {
      const res = findPath(node.children, targetId, newPath);
      if (res) return res;
    }
  }
  return null;
}
```

### 展示上下文与高亮

匹配时不仅要高亮目标节点，也需要展开它的父级节点。这通常用于“搜索后保留上下文”场景。

---

## 三、树的序列化与反序列化

### 什么是树的序列化？

序列化是将树结构“拍扁”成一个平面结构，方便存储或传输。

常见的两种序列化方式：

#### 1. 嵌套结构（children 嵌套）

```json
{
  "id": 1,
  "name": "root",
  "children": [
    {
      "id": 2,
      "name": "child"
    }
  ]
}
```

#### 2. 扁平结构（带 parentId）

```json
[
  { "id": 1, "name": "root", "parentId": null },
  { "id": 2, "name": "child", "parentId": 1 }
]
```

### 反序列化：从扁平结构还原成树

我们可以使用一次遍历 + `Map` 存储方式高效构建：

```ts
function buildTree(flatList) {
  const idMap = new Map();
  const tree = [];

  for (const item of flatList) {
    idMap.set(item.id, { ...item, children: [] });
  }

  for (const item of flatList) {
    const node = idMap.get(item.id);
    if (item.parentId) {
      const parent = idMap.get(item.parentId);
      parent.children.push(node);
    } else {
      tree.push(node);
    }
  }

  return tree;
}
```

---

## 四、树在前端业务中的常见结构设计

### 嵌套结构 vs 扁平数组

| 结构类型 | 优点     | 缺点         |
| -------- | -------- | ------------ |
| 嵌套结构 | 渲染方便 | 查找慢       |
| 扁平结构 | 查找高效 | 渲染需构建树 |

通常推荐后端返回扁平结构，前端根据需要构建嵌套结构。

### 典型结构字段设计

- `id`：唯一标识
- `parentId`：父节点标识
- `path`：从 root 到当前节点的路径，如 `['A', 'A-1', 'A-1-1']`
- `level`：树的层级
- `hasChildren`：是否有子节点（懒加载场景）

### 可配置树结构设计

对于需要灵活扩展的树组件，我们可以：

- 给节点加上 `meta` 字段存扩展信息
- 支持异步加载子节点 `loadChildren`
- 允许配置字段名（如 `idField`, `childrenField`）

---

## 五、实际业务中的案例与抽象

### 权限菜单树

- 权限结构天然就是树形结构（父子菜单）
- 节点中包含权限码、路由、图标等扩展字段
- 通常配合复选框支持“父子联动”

### 电商分类树

- 多层级分类，节点支持重排序
- 拖拽操作需考虑排序字段和层级限制
- 删除分类时需确认是否连带删除子分类

### 流程图 / 组织结构图

- 可视化展示，节点可编辑、移动
- 后端通常维护 flat 数据，前端负责绘图与结构映射

---

## 六、进阶话题（预告）

后续我们还会讨论以下进阶内容：

- 树结构的 diff 算法：比如 Vue3 的 block tree 优化策略
- 虚拟滚动和懒加载：用于大规模树结构的性能优化
- AST 抽象语法树的构建与转换：如何将代码结构转换为树并分析
- 树状缓存管理：基于依赖关系的递归缓存设计

敬请期待 🫡

---
